1. BFS

n = int(input("enter a no. of nodes:"))
graph = {}
for i in range(n):
 print("Enter node:")
 keys = input() # here i have taken keys as strings

 lst = [ ]
 n = int(input("Enter number of elements : "))

 for i in range(0, n):
 ele = str(input())
 lst.append(ele)

 graph[keys] = lst

print(graph)
visited = [] # List to keep track of visited nodes.
queue = [] #Initialize a queue

def bfs(visited, graph, node):
 visited.append(node)
 queue.append(node)
 while queue:
 s = queue.pop(0)
 print (s, end = " ")
 for neighbour in graph[s]:
 if neighbour not in visited:
 visited.append(neighbour)
 queue.append(neighbour)

# Driver Code
bfs(visited, graph, 'A')

2. DFS

n = int(input("enter a no. of nodes:"))
graph = {}
for i in range(n):
 print("Enter node:")
 keys = input() # here i have taken keys as strings

 lst = [ ]
 n = int(input("Enter number of elements : "))

 for i in range(0, n):
 ele = str(input())
 lst.append(ele)

 graph[keys] = lst

visited = set() # Set to keep track of visited nodes of graph.

def dfs(visited, graph, node): #function for dfs
 if node not in visited:
 print (node)
 visited.add(node)
 for neighbour in graph[node]:
 	dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
dfs(visited, graph, 'S')



3. N Queens

# Taking number of queens as input from user
print ("Enter the number of queens")
N = int(input())

# here we create a chessboard
# NxN matrix with all elements set to 0
board = [[0]*N for _ in range(N)]

def attack(i, j):
    #checking vertically and horizontally
    for k in range(0,N):
        if board[i][k]==1 or board[k][j]==1:
            return True
    #checking diagonally
    for k in range(0,N):
        for l in range(0,N):
            if (k+l==i+j) or (k-l==i-j):
                if board[k][l]==1:
                    return True
    return False

def N_queens(n):
    if n==0:
        return True
    for i in range(0,N):
        for j in range(0,N):
            if (not(attack(i,j))) and (board[i][j]!=1):
                board[i][j] = 1
                if N_queens(n-1)==True:
                    return True
                board[i][j] = 0

    return False

N_queens(N)
for i in board:
    print (i)


4. A* algo

from collections import deque

class Graph:

    def __init__(self, adjacency_list):
        self.adjacency_list = adjacency_list

    def get_neighbors(self, v):
        return self.adjacency_list[v]

    def h(self, n):
        H = {
            'A': 1, 
            'B': 1,
            'C': 1,
            'D': 1
        }

        return H[n]

    def a_star_algorithm(self, start_node, stop_node):
       
        open_list = set([start_node])
        closed_list = set([])

        g = {}

        g[start_node] = 0

        parents = {}
        parents[start_node] = start_node

        while len(open_list) > 0:
            n = None

            for v in open_list:
                if n == None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v;

            if n == None:
                print('Path does not exist!')
                return None

            if n == stop_node:
                reconst_path = []

                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]

                reconst_path.append(start_node)

                reconst_path.reverse()

                print('Path found: {}'.format(reconst_path))
                return reconst_path

            for (m, weight) in self.get_neighbors(n):
                
                if m not in open_list and m not in closed_list:
                    open_list.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight

                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                        if m in closed_list:
                            closed_list.remove(m)
                            open_list.add(m)

            open_list.remove(n)
            closed_list.add(n)

        print('Path does not exist!')
        return None
        
adjacency_list = {
    'A': [('B', 1), ('C', 3), ('D', 7)],
    'B': [('D', 5)],
    'C': [('D', 12)]
}
graph1 = Graph(adjacency_list)
graph1.a_star_algorithm('A', 'D')

5. Minimax with alpha-beta pruning


MAX, MIN = 1000, -1000

def minimax(depth, nodeIndex, maximizingPlayer, values, alpha, beta):

	# Terminating condition. i.e
	# leaf node is reached
	if depth == 3:
		return values[nodeIndex]

	if maximizingPlayer:
	
		best = MIN

		# Recur for left and right children
		for i in range(0, 2):
			
			val = minimax(depth + 1, nodeIndex * 2 + i,
						False, values, alpha, beta)
			best = max(best, val)
			alpha = max(alpha, best)

			# Alpha Beta Pruning
			if beta <= alpha:
				break
		
		return best
	
	else:
		best = MAX

		# Recur for left and
		# right children
		for i in range(0, 2):
		
			val = minimax(depth + 1, nodeIndex * 2 + i,
							True, values, alpha, beta)
			best = min(best, val)
			beta = min(beta, best)

			# Alpha Beta Pruning
			if beta <= alpha:
				break
		
		return best
	
# Driver Code
if __name__ == "__main__":

	values = [3, 5, 6, 9, 1, 2, 0, -1]
	print("The optimal value is :", minimax(0, 0, True, values, MIN, MAX))

6. 8 puzzle

from collections import deque

# Define the initial and goal states
initial_state = [[1, 2, 3], [4, 0, 5], [6, 7, 8]]
goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

# Define the actions that can be taken
actions = ['up', 'down', 'left', 'right']

# Define a function to get the possible successor states
def get_successors(state):
    successors = []
    row, col = get_blank_location(state)
    for action in actions:
        new_state = perform_action(state, action, row, col)
        if new_state:
            successors.append(new_state)
    return successors

# Define a function to get the location of the blank tile
def get_blank_location(state):
    for row in range(3):
        for col in range(3):
            if state[row][col] == 0:
                return row, col

# Define a function to perform an action on the state
def perform_action(state, action, row, col):
    if action == 'up':
        if row == 0:
            return None
        new_state = [row[:] for row in state]
        new_state[row][col], new_state[row-1][col] = new_state[row-1][col], new_state[row][col]
        return new_state
    elif action == 'down':
        if row == 2:
            return None
        new_state = [row[:] for row in state]
        new_state[row][col], new_state[row+1][col] = new_state[row+1][col], new_state[row][col]
        return new_state
    elif action == 'left':
        if col == 0:
            return None
        new_state = [row[:] for row in state]
        new_state[row][col], new_state[row][col-1] = new_state[row][col-1], new_state[row][col]
        return new_state
    elif action == 'right':
        if col == 2:
            return None
        new_state = [row[:] for row in state]
        new_state[row][col], new_state[row][col+1] = new_state[row][col+1], new_state[row][col]
        return new_state

# Define a function to check if the current state is the goal state
def is_goal(state):
    return state == goal_state

# Define the breadth-first search algorithm
def bfs_search(initial_state):
    frontier = deque([initial_state])
    explored = set()
    while frontier:
        state = frontier.popleft()
        if is_goal(state):
            return state
        explored.add(str(state))
        for successor in get_successors(state):
            if str(successor) not in explored:
                frontier.append(successor)
    return None

# Call the breadth-first search function and print the solution
solution = bfs_search(initial_state)
if solution:
    print('Solution:', solution)
else:
    print('No solution found.')


7. PROLOG
Fruit.pl : ruit(mango). fruit(banana). fruit(orange). has(seema, mango). has(payal, banana). has(deepak, orange). 
Queries : fruit(X) has(seema, X). has(X, banana). has(deepak, X). has(X,mango), has(Y,banana), has(Z,orange).

Family.pl: man(anand).
man(arun). woman(anuradha).
woman(pooja). parent(anand , parth).
parent(arun, anuradha). parent(pooja,
anuradha). parent(anuradha,parth).
father(F, A) :- man(F) , parent(F, A).
mother(M, A) :- woman(M), parent(M, A).

Queries: father(X,parth).
mother(X,parth).
mother(X,_). father(X,_).
parent(X,Y).

factorial(0,1). factorial(N,X):-factorial(N1,X1),N is N1+1,X is X1*N.

factorial(6,X)

fibonacci(1,1). fibonacci(2,1). fibonacci(N,X):-N>=3,N1 is N-1,N2 is N-2, fibonacci(N1,X1),fibonacci(N2,X2),X is X1+X2.

fibonacci(5, X)


Reult.pl : result(ram, 9.2). result(sam,8.2). result(piyush,7.2). result(priya,9.6). result(sudha ,6.8). result(madhur,5.2). result(mandar,8.2). getresult :- write("Whose result do you want to know"),nl, read(X),nl, result(X,Y),nl, write("this is the result"),nl, write(Y).


max(X,Y,X) :- X >= Y,!. max(X,Y,Y) :- X < Y. max_find(X,Y,Max) :- X >= Y,!, Max = X; Max = Y. 

list_member(X,[X|_]) :- !. list_member(X,[_|TAIL]) :- list_member(X,TAIL). list_append(A,T,T) :- list_member(A,T),!. list_append(A,T,[A|T]). 
